---
title: 'MicroFrontend: integraci√≥n sin host ‚Äî pr√°cticas y configuraci√≥n'
description: 'En esta tercera parte comparto c√≥mo logr√© integrar un m√≥dulo frontend en un entorno sin host definido, integrando directamente  en un  m√≥dulo padre.'
publishedAt: '2025-06-02'
type: 'article'
tags:
  - 'MicroFrontend'
---

En algunos proyectos, los m√≥dulos se desarrollan en paralelo antes de que exista una aplicaci√≥n contenedora (host) claramente definida. Ese fue mi caso: trabajaba en un m√≥dulo independiente que deb√≠a integrarse con otro m√≥dulo de mayor jerarqu√≠a, sin tener a√∫n claridad sobre el host final.

<SeriesBlock
  title="Integrando Microfrontends en Proyectos Reales"
  items={[
    {
      label: 'Parte 1: MicroFrontend sin aplicaci√≥n contenedora',
      href: '/blog/microfrontends-sin-aplicacion-contenedora',
    },
    {
      label:
        'Parte 2: MicroFrontend: el escenario ideal para una integraci√≥n ordenada',
      href: '/blog/microfrontends-escenario-ideal',
    },
    {
      label:
        'Parte 3: MicroFrontend: integraci√≥n sin host ‚Äî pr√°cticas y configuraci√≥n',
      href: '/blog/microfrontends-integracion-sin-host',
      current: true,
    },
  ]}
/>

En este escenario, el flujo era m√°s o menos as√≠:

- M√≥dulo principal (host, a√∫n sin definir).
  - M√≥dulo Z (m√≥dulo padre).
    - M√≥dulo X (m√≥dulo que solo vivir√° dentro del m√≥dulo padre).

Esto trajo una serie de retos t√©cnicos que fuimos resolviendo con buena comunicaci√≥n y decisiones pr√°cticas. En este art√≠culo comparto algunas de esas pr√°cticas que me sirvieron para lograr una integraci√≥n funcional. Para el ejemplo, utilizaremos PrimeReact y Redux Toolkit como librer√≠as de ejemplo.

## 1. Alinear versiones de librer√≠as compartidas

Debemos identificar qu√© versiones de librer√≠as est√° usando el m√≥dulo padre, para asegurarnos de que sean compatibles con el m√≥dulo que vamos a integrar.

```json:package.json
"primereact": "9.6.1",
"primereact-icons": "9.6.1",
"react-redux": "9.6.1",
"@reduxjs/toolkit": "2.5.0",
```

Esto debe quedar reflejado tambi√©n en el `webpack.config.js` dentro de la secci√≥n `shared`:

```js:webpack.config.js
shared: {
  // ... otros shared: react, react-dom, react-router-dom, etc.
  "primereact": {
    singleton: true,
    strictVersion: true,
    requiredVersion: deps["primereact"],
  },
  "primereact-icons": {
    singleton: true,
    strictVersion: true,
    requiredVersion: deps["primereact-icons"],
  },
  "react-redux": {
    singleton: true,
    strictVersion: true,
    requiredVersion: deps["react-redux"],
  },
  "@reduxjs/toolkit": {
    singleton: true,
    strictVersion: true,
    requiredVersion: deps["@reduxjs/toolkit"],
  },
  // ... otros shared
}
```

## 2. Configura el nombre del m√≥dulo y lo que expone

Configura correctamente el `webpack.config.js` para exponer lo que realmente necesita el m√≥dulo padre(host). Esto incluye tu componente principal, slices, hooks, adaptadores, etc. Todo lo que necesite tu m√≥dulo para que funcione correctamente.

```js:webpack.config.js
...
name: 'moduleAppX',
filename: 'remoteEntry.js',
exposes: {
  "./ModuleComponent": "./src/main.tsx",
  "./ModuleSlices": "./src/application/slices/index.ts",
  "./ModuleApi": "./src/infrastructure/http/apiClient.ts",
  "./ModuleHooks": "./src/application/hooks/expose.ts",
  "./ModuleAdapter": "./src/application/adapters/expose.ts",
},
...
```

## 3. Evita conflictos con los estilos TailwindCSS

Cuando no hay un dise√±o UI unificado, cada equipo crea estilos tailwind para su m√≥dulo a su criterio. Por eso, para evitar conflictos, configura Tailwind (`v3.4`) para que sus clases est√©n encapsuladas:

```js:tailwind.config.js
module.exports = {
  content: ['./src/**/*.{ts,tsx,html}'],
  important: '#module-app-x', // Usa un id √∫nico de tu m√≥dulo
  theme: {
    extend: {},
  },
  plugins: [],
};
```

Y dependiendo de como crees tu componente principal(main), puedes usar el id √∫nico de tu m√≥dulo para que los estilos de tailwind solo afecten al contenido de tu m√≥dulo.

```tsx:main.tsx {4}

export const ModuleX = () => {
  return (
    <div id="module-app-x">
      <h1>Hola Mundo</h1>
    </div>
  );
};
```

## 4. Importa el CSS necesario en el componente remoto

Cuando utilizas otras librer√≠as, como `react-loading-skeleton`, requieren importar su archivo CSS para que los estilos se apliquen correctamente. Si no lo haces, es posible que los componentes no se rendericen como deber√≠an.

```tsx:main.tsx
import 'react-loading-skeleton/dist/skeleton.css';

// ...
```

En mi caso, los estilos de `react-loading-skeleton` no se aplicaban hasta que los import√© expl√≠citamente en el componente remoto.

## 5. Integra tus reducers o middleware en el m√≥dulo padre (Redux Toolkit)

Coordina con el equipo del host c√≥mo se van a integrar tus slices o servicios RTK. Aseg√∫rate de exponerlos y que el host los incluya en su configureStore.

```ts:module_app_z/store.ts
// En el m√≥dulo padre
import { moduleReducer } from 'moduleAppX/ModuleSlices';
import { api as apiModule } from 'moduleAppX/ModuleApi';

// En el store del m√≥dulo padre
const mainStore = configureStore({
  reducer: {
    // ... otros reducers
    // ModuleAppX
    modulo: moduleReducer,
    [apiModule.reducerPath]: apiModule.reducer,
    // ... otros reducers
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(apiModule.middleware),
});
```

Esto asegura que tu m√≥dulo pueda consumir la informaci√≥n desde el store del m√≥dulo padre.

## 6. Evita duplicar estilos que ya est√°n en el host

Algunas librer√≠as como PrimeReact o Bootstrap incluyen CSS que probablemente ya est√©n importados por el m√≥dulo padre. Verifica antes de incluirlos nuevamente para evitar conflictos de estilos.

## 7. Asegura la compatibilidad con TypeScript

Si usas TypeScript, crea en el m√≥dulo padre un archivo `remote.d.ts` para declarar los m√≥dulos remotos que vas a importar:

```ts:module_app_z/types/remote.d.ts
declare module 'moduleAppX/ModuleComponent';
declare module 'moduleAppX/ModuleApi';
declare module 'moduleAppX/ModuleSlices';
declare module 'moduleAppX/ModuleHooks';
declare module 'moduleAppX/ModuleAdapter';
```

Y aseg√∫rate de que el m√≥dulo padre declare el remote en su `webpack.config.js` para que el autocompletado y los tipos funcionen correctamente.

```js:webpack.config.js
...
remotes: {
  moduleAppX: 'moduleAppX@https://your-app-domain.xyz/remoteEntry.js',
},
...
```

## 8. Realiza pruebas aisladas e integradas desde el inicio

Es √∫til separar la l√≥gica de tu componente en dos archivos:

- `main.tsx`: solo exporta el componente que se va a consumir de forma remota.

```tsx:main.tsx
import 'react-loading-skeleton/dist/skeleton.css';

export { ModuleX } from './presentation/pages/ModuleX';
```

- `bootstrap.tsx`: para probar el m√≥dulo de forma individual, con todo el contexto necesario.

```tsx:bootstrap.tsx
import { createRoot } from 'react-dom/client';
import { ModuleX } from './presentation/pages/ModuleX';
import { store } from './application/store';
import { Provider } from 'react-redux';
import 'primereact/resources/themes/saga-blue/theme.css';
import 'primereact/resources/primereact.min.css';
import 'primeicons/primeicons.css';

const container = document.getElementById('root')!;
const root = createRoot(container);

root.render(
  <Provider store={store}>
    <ModuleX />
  </Provider>
);
```

De esta forma, aseguramos el correcto funcionamiento de nuestro m√≥dulo dentro del m√≥dulo padre.

**Conclusi√≥n:**

Integrarse sin un host definido requiere comunicaci√≥n, orden y algo de paciencia. Estas pr√°cticas me ayudaron a lograrlo de forma m√°s fluida, y espero que tambi√©n te sean √∫tiles si est√°s en una situaci√≥n parecida.

{/* üëâ Si tienes alguna duda o quieres compartir tu experiencia, estar√© encantado de leerte. */}

üëâ Puedes volver a la parte anterior: [MicroFrontend: el escenario ideal para una integraci√≥n ordenada](/blog/microfrontends-escenario-ideal)
