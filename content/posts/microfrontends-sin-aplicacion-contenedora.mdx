---
title: 'MicroFrontend: consideraciones al trabajar sin una aplicaci√≥n contenedora'
description: 'En esta primera parte comparto buenas pr√°cticas y decisiones clave para trabajar con microfrontends cuando a√∫n no existe una aplicaci√≥n contenedora definida (host).'
publishedAt: '2025-05-27'
type: 'article'
tags:
  - 'MicroFrontend'
---

En muchos proyectos reales, los equipos comienzan a desarrollar sus m√≥dulos antes de tener una aplicaci√≥n contenedora (conocida tambi√©n como _host_ o _shell_). Esta situaci√≥n es com√∫n, especialmente en entornos √°giles, donde se busca avanzar de manera paralela sin bloqueos.

<SeriesBlock
  title="Integrando Microfrontends en Proyectos Reales"
  items={[
    {
      label: 'Parte 1 - MicroFrontend: sin aplicaci√≥n contenedora',
      href: '/blog/microfrontends-sin-aplicacion-contenedora',
      current: true,
    },
    {
      label:
        'Parte 2 - MicroFrontend: el escenario ideal para una integraci√≥n ordenada',
      href: '/blog/microfrontends-escenario-ideal',
    },
    {
      label:
        'Parte 3 - MicroFrontend: integraci√≥n sin host ‚Äî pr√°cticas y configuraci√≥n',
      href: '/blog/microfrontends-integracion-sin-host',
    },
  ]}
/>

En esta primera parte comparto algunas consideraciones t√©cnicas y organizativas que pueden ayudarte cuando se trabaja con m√≥dulos independientes, sin tener a√∫n una aplicaci√≥n contenedora definida.

## 1. Define claramente si trabajas con m√≥dulos o subm√≥dulos

Antes de comenzar, identifica si tu m√≥dulo se integrar√° directamente en la aplicaci√≥n principal o ser√° parte de otro m√≥dulo (un subm√≥dulo). Esto cambia las decisiones t√©cnicas: desde qu√© dependencias necesitar√°s hasta c√≥mo manejar el contexto.

> **¬øPor qu√© esto importa?** Un subm√≥dulo depende m√°s del m√≥dulo que lo contiene. Anticiparlo evita reestructuraciones m√°s adelante.

## 2. Dise√±a cada m√≥dulo como si fuera remoto

Aunque el m√≥dulo se monte temporalmente en otro para avanzar, es buena pr√°ctica tratarlo como un microfrontend independiente desde el inicio. Esto simplifica su futura exposici√≥n e integraci√≥n.

## 3. Usa convenciones claras desde el inicio

Define c√≥mo se expondr√°n los elementos principales del m√≥dulo, como componentes, slices, adapters y hooks. Algunos ejemplos comunes son: `./ModuloComponent`, `./ModuloSlices`, `./ModuloHooks`.

## 4. Gestiona cuidadosamente las dependencias compartidas

Asegura que cada m√≥dulo configure correctamente sus dependencias compartidas (por ejemplo, `react`, `react-dom`, `@reduxjs/toolkit`) usando Module Federation con la opci√≥n `singleton`.

Adem√°s, todos los m√≥dulos deben usar la **misma versi√≥n** de estas dependencias para evitar errores o comportamientos inesperados al integrarse.

## 5. Mant√©n aislado el estado y los estilos

Cada m√≥dulo deber√≠a tener su propio estado local, sobre todo si a√∫n no existe un store global. Esto ayuda a que los equipos trabajen sin depender unos de otros.

En estilos, conviene usar soluciones como Tailwind con `prefix` o CSS Modules. As√≠ evitas conflictos visuales cuando se cargan varios m√≥dulos en una misma vista.

## 6. Exporta solo lo necesario

Durante el desarrollo es normal usar un archivo bootstrap para probar tu m√≥dulo de forma aislada. All√≠ puedes importar todo lo que necesites.

Pero al momento de exportarlo (por ejemplo, en `main.tsx`), incluye solo lo esencial. No dupliques recursos que ya aporta la aplicaci√≥n contenedora, como los estilos de alguna librer√≠a de componentes.

## 7. Documenta claramente lo que expones

Un documento breve, pero claro, con lo que el m√≥dulo expone (componente, slice, hook, etc.) facilita que otros equipos lo integren sin fricci√≥n.

## 8. Comunicaci√≥n constante entre equipos y apoyo mutuo

Aunque los equipos trabajen en paralelo, es clave mantener la coordinaci√≥n. Reuniones cortas y constantes ayudan a alinear criterios y prevenir bloqueos antes de que escalen.

> **¬øPor qu√© es importante?** Coordinar temprano es m√°s barato que corregir tarde.

## Conclusi√≥n

La integraci√≥n puede llegar despu√©s de varios sprints, cuando ya se espera ver avances funcionales de los m√≥dulos integrados. Por eso, mantener una buena comunicaci√≥n entre equipos es esencial para evitar contratiempos.

### Glosario

**Aplicaci√≥n contenedora (host / shell):** Aplicaci√≥n principal que orquesta e integra los m√≥dulos desarrollados de forma independiente. Se encarga de manejar navegaci√≥n, estilos globales y carga din√°mica de microfrontends.

**Microfrontend:** M√≥dulo de frontend que se puede desarrollar, desplegar e integrar de manera aut√≥noma, como parte de una aplicaci√≥n mayor.

**Module Federation:** Funcionalidad de Webpack que permite compartir m√≥dulos entre aplicaciones en tiempo de ejecuci√≥n.

**Bootstrap (en este contexto):** Archivo que sirve para probar un m√≥dulo de forma aislada, sin depender de la aplicaci√≥n principal.

**Singleton:** Opci√≥n que se usa en `Module Federation` para compartir una sola instancia de una dependencia entre m√∫ltiples m√≥dulos.

**Prefix (en Tailwind):** Configuraci√≥n que permite evitar conflictos de estilos entre m√≥dulos usando un prefijo en las clases CSS.

Gracias por leer, que tengas un d√≠a maravilloso. üåû

üëâ Contin√∫a con la siguiente parte: [MicroFrontend: El escenario ideal](/blog/microfrontends-escenario-ideal)
